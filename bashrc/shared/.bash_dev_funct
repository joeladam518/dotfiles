# Development functions

# Link a local composer-package repo to another project for testing
composer_link()
{
    composer config repositories.local '{"type": "path", "url": "'${1}'"}' --file composer.json
}

# Change to a repo directory based on a alias file you define in your home directory
repo() {
    local repos line key aliased aliases_path
    aliases_path="${HOME}/.repo-aliases"

    # convert file to bash array
    if [ -f "$aliases_path" ] && [ -r "$aliases_path" ]; then
        eval "$(__repo-helper --file="${aliases_path}" --name=repos)"
    else
        declare -A repos
    fi

    # add repo directories that we didn't define in out aliases file to our array
    aliased="$(printf '%s\n' "${repos[@]}")"
    for line in "${HOME}/repos/"*; do
        if ! (echo "$aliased" | grep -xq "$line"); then
            repos["$(basename "$line")"]="$line"
        fi
    done

    key="${1}"
    if [ -z "${key}" ]; then
        echo "You must specify a key" 1>&2
        return 1
    fi

    # Check if key exists in the array
    if ! [ ${repos[$key]+bob} ]; then
        echo "invalid option ${1}" 1>&2
        return 1
    fi

    cd "${repos[$key]}" || return 1

    return 0
}

#
# Docker functions
#

# Bring up SIDTK -> https://github.com/sourcetoad/DevopsToolKit
dkrconnect()
{
    local CWD ST_DSS_DIR ST_DST_DIR
    CWD="$(pwd)"
    ST_DSS_DIR="${HOME}/devop-tools/docker/data-source-services"
    ST_DST_DIR="${HOME}/devop-tools/docker/data-source-tools"

    if [ ! -d "$ST_DSS_DIR" ]; then
        echo "data source services not found... What are you trying to connect to?"
        return 1
    fi

    if [ ! -d "$ST_DST_DIR" ]; then
        echo "data source tools not found... "
        return 1
    fi

    # trap "cd ${cwd}" RETURN
    cd "$ST_DSS_DIR" && docker-compose up --build -d && cd "$ST_DST_DIR" && docker-compose up --build -d && cd "$CWD"
}

#
# Git functions
#

next_release() {
    git log "${2:-"staging..master"}" --oneline --no-merges | grep -Eio "${1}-([0-9]+)" | tr a-z A-Z | sort | uniq
}

# Automatically try to delete dead baranches on local
git_removeAllUnmergedLocalBranchesNotOnRemoteFunction()
{
    echo "Didn't do anything. TODO: finish this function :-)"
    exit 0

    # This seemed to work on 2019-02-28 and again on 2020-09-15
    # notes: https://stackoverflow.com/questions/13064613/how-to-prune-local-tracking-branches-that-do-not-exist-on-remote-anymore
    # Whats left TODO: take any branches that throw errors and list them out

    git fetch -p && git branch -r | awk '{print $1}' | grep -E -v -f /dev/fd/0 <(git branch -vv | grep origin) | awk '{print $1}' | xargs git branch -d
}

#
# Greenbar git functions
#

greenbar_newBranchFunction()
{
    git checkout develop && git pull upstream develop && git push && git checkout -b "$1"
}
greenbar_prepBranchFunction()
{
    local branch_name

    if [ -n "$(git status --porcelain)" ]; then
        echo "You must commit your changes first.";
    else
        branch_name="$(git symbolic-ref HEAD 2>/dev/null)" ||
        branch_name="(unnamed branch)" # detached HEAD
        branch_name="${branch_name##refs/heads/}"

        git checkout develop && git pull upstream develop && git push && git checkout "$branch_name" && git merge develop
    fi
}
greenbar_pushBranchFunction()
{
    local branch_name

    if [ -n "$(git status --porcelain)" ]; then
        echo "You must commit your changes first.";
    else
        branch_name="$(git symbolic-ref HEAD 2>/dev/null)" ||
        branch_name="(unnamed branch)"     # detached HEAD
        branch_name=${branch_name##refs/heads/}

        git checkout develop && git merge "$branch_name" && git push
    fi
}
