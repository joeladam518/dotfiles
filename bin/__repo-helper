#!/usr/bin/env python3
# Parse your repo aliases file for a list of keys (aliases),
# a list of paths, or a bash multidimensional array
import os
from argparse import ArgumentParser
from configparser import ConfigParser
from getpass import getuser
from typing import Optional


# Functions
def get_repo_aliases(aliases: dict, repos_directory: str) -> dict:
    repos_directory = os.path.expanduser(repos_directory)

    if not os.path.exists(repos_directory):
        raise Exception(f"'{repos_directory}' doesn't exist.")

    aliases = {key: os.path.expanduser(path) for (key, path) in aliases.items()}
    aliases_keys = list(aliases.keys())
    aliases_paths = list(aliases.values())
    new_aliases = {}

    def get_aliases_key(val) -> Optional[str]:
        try:
            pos = aliases_paths.index(val)
        except ValueError:
            return None

        return aliases_keys[pos]

    # add all folders in the repos directory making sure to swap the aliases key if found
    for f in os.scandir(repos_directory):
        if not f.is_dir():
            continue
        path = os.path.abspath(f.path)
        key = get_aliases_key(path)
        new_aliases[key if key else f.name] = path

    # see if there are any aliases that didn't get added and add them
    paths_to_add = [path for path in aliases.values() if path not in new_aliases.values()]
    for path in paths_to_add:
        key = get_aliases_key(path)
        if key:
            new_aliases[key] = path

    return new_aliases


def parse_script_args():
    parser = ArgumentParser(description='Parse your repo aliases into keys, values, or a bash array.')

    parser.add_argument('file', type=str, action='store',
                        help="repo aliases file path")
    parser.add_argument('-d', '--dir', action='store', default=os.path.expanduser(f"~{getuser()}/repos"),
                        help="set the directory where your repos are located")
    parser.add_argument('-n', '--name', action='store', default='repos',
                        help="set the variable name of your bash array")
    parser.add_argument('-s', '--sep', type=str, action='store', default="\n",
                        help="set the seperator for keys and paths")
    parser.add_argument('-k', '--keys', action='store_true', default=False,
                        help="get repo aliases's keys")
    parser.add_argument('-p', '--paths', action='store_true', default=False,
                        help="get repo aliases's paths")

    return parser.parse_args()


def print_bash_array(aliases: dict, name: str) -> None:
    print(f'declare -A {name}')
    for key, path in aliases.items():
        print(f'{name}[{key}]="{path}"')


def separator(seperator: str) -> str:
    if seperator == ' ':
        return ' '

    if seperator == r'\n':
        return os.linesep

    if seperator == r'\t':
        return '\t'

    return seperator


if __name__ == '__main__':
    args = parse_script_args()
    config_parser = ConfigParser()

    with open(args.file, 'r') as file:
        config_parser.read_string(f'[{args.name}]\n' + file.read())

    repo_aliases = get_repo_aliases(dict(config_parser.items(args.name)), args.dir)

    if args.keys:
        print(*repo_aliases.keys(), sep=separator(args.sep))
    elif args.paths:
        print(*repo_aliases.values(), sep=separator(args.sep))
    else:
        print_bash_array(repo_aliases, name=args.name)

