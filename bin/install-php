#!/usr/bin/env python3
import argparse
import os
import subprocess
import sys
from collections import OrderedDict

SUCCESS = 0
FAILURE = 1

php_install_versions = (
    '7.4',
    '8.0',
    '8.1'
)
php_uninstall_versions = (
    '5.4',
    '5.5',
    '5.6',
    '7.0',
    '7.1',
    '7.2',
    '7.3',
    '7.4',
    '8.0',
    '8.1'
)
php_extensions = {
    "common": [
        'bcmath',
        'cli',
        'common',
        'curl',
        'mbstring',
        'mysql',
        'opcache',
        'pgsql',
        'readline',
        'sqlite3',
        'xml',
        'zip',
    ],
    "desktop": [],
    "development": [
        'dev',
        'igbinary',
        'intl',
        'memcached',
        # 'pcov',  # code coverage
        'redis',
        'xdebug',
    ],
    "server": [
        'fpm',
        'gd',
        'igbinary',
        # 'imap',  # work with IMAP protocol, as well as the NNTP, POP3 and local mailbox access methods.
        'intl',
        'memcached',
        'redis',
    ],
}


# functions
def confirm(question: str, tries: int = 2) -> bool:
    question = f"{question} [y/N] "
    valid = {"yes": True, "ye": True, "y": True, "no": False, "n": False}

    while tries > 0:
        choice = input(question).lower()

        if choice in valid:
            return valid[choice]

        tries = tries - 1

        if tries > 0:
            print('Error: invalid input')
            print("options: yes | y | no | n")

    return False


def extensionize(extension: str, version: str = '') -> str:
    return f"php{version}-{extension}"


def get_installed_packages(version: str) -> list:
    cmd = "dpkg -l | grep php%s | sed 's/^ii\s*//' | sed 's/\s\{3,\}.*$//' | tr '\n' ' '"
    packages = run_command(cmd % version, capture_output=True)
    packages = packages.strip().split(' ')

    return list(filter(lambda package: bool(package), packages))


def list_exclude(items: list, excluded: list) -> list:
    for exclude in excluded:
        try:
            items.remove(exclude)
        except ValueError:
            pass

    return items


def list_unique(items: list) -> list:
    return list(OrderedDict.fromkeys(items))


def parse_script_args():
    parser = argparse.ArgumentParser(description='Install/Uninstall php for a given environment')
    parser.add_argument('version', type=str, action='store',
                        help='The version to install.')
    parser.add_argument('--uninstall', action='store_true', default=False,
                        help='Uninstall the php version instead of install.')
    parser.add_argument('--env', type=str, action='store', choices=['desktop', 'development', 'server'],
                        default='desktop', help="The type of environment you're installing php on")
    parser.add_argument('--append', type=str, action='extend', nargs="+", default=[],
                        help='Additional extensions to install')
    parser.add_argument('--exclude', type=str, action='extend', nargs="+", default=[],
                        help='Extensions you want to exclude')
    parser.add_argument('-v', '--verbose', action='count', default=0, help='Output verbosity')

    return parser.parse_args()


def php_install(version: str, env: str = 'desktop', append: tuple = (), exclude: tuple = (), verbose: int = 0) -> int:
    if version not in php_install_versions:
        print('Invalid php version')
        return FAILURE

    if env not in ['desktop', 'development', 'server']:
        print('Environment not supported')
        return FAILURE

    # combine the packages to be installed
    extensions = [*php_extensions["common"], *php_extensions[env], *list(append)]

    if to_tuple_version(version) < (8, 0):
        extensions.append('json')

    # filter out any extensions
    extensions = list_unique(extensions)
    extensions = list_exclude(extensions, list(exclude))

    # build the extension strings and add them to the packages list
    packages = [f"php{version}", *list(map(lambda ext: extensionize(ext, version), extensions))]

    if verbose > 0:
        print(f"php version: {version}")
        print(f"environment: {env}")
        print(f"additional extensions: {', '.join(append)}")
        print(f"excluded extensions: {', '.join(exclude)}")

    print("")
    print("Packages to be installed:")
    print(*packages, sep='\n')

    print("")
    if confirm('Proceed?'):
        run_command("sudo apt update")
        run_command("sudo apt install -y", *packages)
    else:
        print("Exiting...")

    print("")
    return SUCCESS


def php_uninstall(version: str) -> int:
    if version not in php_uninstall_versions:
        print("Invalid php version")
        return FAILURE

    packages = get_installed_packages(version)

    if len(packages) == 0:
        print("")
        print(f"No packages found for php{version}")
        print("")
        return SUCCESS

    print("")
    print('Packages to be uninstalled:')
    print(*packages, sep='\n')

    print("")
    if confirm('Proceed?'):
        run_command("sudo apt purge -y", *packages)
        run_command("sudo apt-get --purge autoremove -y")
    else:
        print("Exiting...")

    print("")
    return SUCCESS


def run_command(cmd: str, *args, **kwargs):
    arguments = [cmd, *args]
    shell = os.environ['SHELL']
    capture_output = bool(kwargs.get('capture_output', False))

    proc = subprocess.run(
        ' '.join(arguments),
        check=True,
        shell=True,
        executable=shell,
        capture_output=capture_output
    )

    if capture_output:
        return proc.stdout.decode(sys.getdefaultencoding())
    else:
        return proc


def to_tuple_version(version: str) -> tuple:
    version_parts = version.split('.')
    return tuple(map(lambda part: int(part), version_parts))


if __name__ == '__main__':
    if sys.version_info < (3, 8):
        print('python 3.8 and above is required')
        sys.exit(FAILURE)

    script_args = parse_script_args()

    if script_args.uninstall:
        exit_status = php_uninstall(version=script_args.version)
    else:
        exit_status = php_install(
            version=script_args.version,
            env=script_args.env,
            append=tuple(script_args.append),
            exclude=tuple(script_args.exclude),
            verbose=script_args.verbose
        )

    sys.exit(exit_status)
